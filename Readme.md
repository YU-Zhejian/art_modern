# Readme for `art_modern`: Modernized ART

**WARNING** Largely under development in internal Git hosting. The Git repository on GitHub may not reflect the latest status.

## Motivation

ART is an excellent software for simulating reads from a reference genome. However, it comes with the following limitations:

- The implementation is not parallelized.
- The implementation may consume too much memory or fail on genomes that contain a limited number of chromosomes of enormous (larger than signed int32) sizes.
- The implementation may consume too much memory or fail on transcriptome or template collection that contains an enormous number of contigs (cDNAs or other types of template molecules).
- The implementation only supports unified coverage, which is not suitable for transcriptome simulation where each cDNA molecule has its own expression level.
- The implementation outputs alignments in SAM format, which is not space-efficient. We also spot some SAM records generated by `art_illumina` have CIGAR strings of inconsistent length.

So, we developed `art_modern` with the following ideas:

- Parallelization is implemented using another layer of abstraction, simulation job, which can be taken as a unit of work in one thread \& process \& co-routine, etc.
- Writer for SAM output format was re-implemented using [HTSLib](https://www.htslib.org/), which allows supporting BAM and headless SAM/BAM output format with minimal modifications of code.
- Multiple FASTA parsers were added. For example, the `htslib` parser allows on-disk random access of enormous genomes without reading them into memory, while the `stream` parser allows streaming of FASTA files.

## Quick Start

Build the project using:

```shell
mkdir -p build_release
env -C build_release cmake -DCMAKE_BUILD_TYPE=Release -DCEU_CM_SHOULD_ENABLE_TEST=FALSE ..
env -C build_release make
```

The project binary will be available at `build_release/art_modern`.

## Installation

### Dependencies

- [CMake](https://cmake.org/), the building system used in our project. That further require:
  - A [CMake Generator](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html).
    - Under GNU/Linux, using [Ninja](https://ninja-build.org/) or [GNU Make](https://www.gnu.org/software/make) is preferred.
  - Under GNU/Linux, our project further requires [GNU Bash](https://www.gnu.org/software/bash).
- A working C and C++ compiler that supports C++ 14. The following compilers are supported:
  - [GCC](https://gcc.gnu.org/);
  - [Clang](https://clang.llvm.org/);
  - [Intel oneAPI DPCPP](https://www.intel.com/content/www/us/en/docs/dpcpp-cpp-compiler/get-started-guide/2024-2/overview.html).
- [Boost C++ Library](https://www.boost.org/). This is an umbrella project of diverse small modules that can be used independently. Consult your system administrator for where to find them. The modules used in this project are namely:
  - **REQUIRED** [FileSystem](https://www.boost.org/doc/libs/1_85_0/libs/filesystem/);
  - **REQUIRED** [Regex](https://www.boost.org/doc/libs/1_85_0/libs/regex/);
  - **REQUIRED** [Program Options](https://www.boost.org/doc/libs/1_85_0/libs/program_options/);
  - **REQUIRED** [Thread](https://www.boost.org/doc/libs/1_85_0/libs/thread/);
  - **REQUIRED** [Log](https://www.boost.org/doc/libs/1_85_0/libs/log/);
  - **REQUIRED** [StackTrace](https://www.boost.org/doc/libs/1_85_0/doc/html/stacktrace.html);
  - **OPTIONAL** [Test](https://www.boost.org/doc/libs/1_85_0/libs/test/): For unit testing only. Can be absent for non-developers;
  - **OPTIONAL** [Timer](https://www.boost.org/doc/libs/1_85_0/libs/timer/): For displaying CPU and wall-clock time at the end of the program.
  - **OPTIONAL** `stacktrace_backtrace`: See [here](https://www.boost.org/doc/libs/1_85_0/doc/html/stacktrace/configuration_and_build.html) for details.
- A working [HTSLib](https://www.htslib.org/). You may either use the one bundled with the project or an external one that had already been installed inside your system.
  - To use bundled HTSLib sources, you need to have:
    - **REQUIRED** [zlib](https://www.zlib.net/);
    - **REQUIRED** [pthread](https://www.man7.org/linux/man-pages/man7/pthreads.7.html);
    - **OPTIONAL** [libbz2](http://www.bzip.org/);
    - **OPTIONAL** [liblzma](https://tukaani.org/xz/); 
    - **OPTIONAL** [libdeflate](https://github.com/ebiggers/libdeflate);
    - See [official HTSLib documentation](https://github.com/samtools/samtools/blob/master/INSTALL) for more details.
  - To use external HTSLib, consult your system administrator.
- Optional libraries for random generators. Including:
  - [Intel OneAPI Math Kernel Library (MKL)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html);
  - [GNU Science Library (GSL)](https://www.gnu.org/software/gsl/).
- Optional MPI library for MPI-based parallelism.
  - MPI implementations (library and compiler). The following MPI implementations are supported:
    - [MPICH](https://www.mpich.org/).
    - [OpenMPI](https://www.open-mpi.org/).
    - [Intel MPI](https://www.intel.com/content/www/us/en/developer/tools/oneapi/mpi-library.html).
    - [MS-MPI](https://learn.microsoft.com/en-us/message-passing-interface/microsoft-mpi) (For working under MSYS2). See also: [MSYS2 Package Repository](https://packages.msys2.org/packages/mingw-w64-x86_64-msmpi)
  - Google Protocol Buffers (Protobuf) for serialization/deserialization of MPI.

### CMake Variables

CMake variables should be set when invoking `cmake`. For example,

```shell
cmake -DBUILD_SHARED_LIBS=ON
```

sets `BUILD_SHARED_LIBS` to `ON`.

- `BUILD_SHARED_LIBS`: Whether to build shared libraries
  - **`ON` (DEFAULT): Will search for shared libraries and use dynamic linking.**
  - `OFF`: Will search for static libraries and use static linking.
- `USE_HTSLIB`: Use which HTSLib implementation
  - **unset (DEFAULT): Will use bundled HTSLib.**
  - `hts`: Will use the HTSLib (`libhts.so`) found in system.
- `CEU_CM_SHOULD_ENABLE_TEST`: Whether test should be enabled.
  - **unset (DEFAULT): Set to `ON` if the CMake variable `CMAKE_BUILD_TYPE` is not `Release`, `OFF` otherwise.**
  - `OFF`: Will disable test.
  - `ON`: Will enable test.
- `CEU_CM_SHOULD_USE_NATIVE`: Whether to build the binaries using [`-mtune=native`](https://gcc.gnu.org/onlinedocs/gcc-14.1.0/gcc/x86-Options.html#index-march-16), if possible. This would result in faster executable but impaired portability.
  - **`OFF` (DEFAULT): Will not build native executables/libraries.**
  - `ON`: Will build native executables/libraries.
- [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html): The CMake build type.
  - **`Debug` (DEFAULT): For developers with debugging needs.**
    - Optimization is turned off with debugging symbols and compiler warnings enabled.
    - If `CEU_CM_SHOULD_ENABLE_TEST` is unset, it will be set to `TRUE`.
  - `Release`: Optimized executables/libraries without debug symbols.
    - Optimization is turned on with compiler warnings disabled.
    - If `CEU_CM_SHOULD_ENABLE_TEST` is unset, it will be set to `FALSE`.
  - `RelWithDebInfo`: Optimized executables/libraries with debug symbols.
    - Optimization is turned on with compiler warnings disabled.
    - If `CEU_CM_SHOULD_ENABLE_TEST` is unset, it will be set to `TRUE`.
- `USE_RANDOM_GENERATOR`: The random number generator used.
  - **`STL` (DEFAULT): Use STL random generators.**
  - `BOOST`: Use Boost random generators.
  - `GSL`: Use GSL random generators.
  - `ONEMKL`: Use Intel OneAPI MKL random generators. Highly recommended on Intel CPUs.
- `USE_ASIO_PARALLEL`: Whether to use Boost ASIO for thread-based parallelism.
  - **`ON` (DEFAULT): Will use Boost ASIO for thread-based parallelism.**
  - `OFF`: Will not use Boost ASIO for thread-based parallelism.


## Usage

### Mode

The parallelization strategy of different modes and input parsers are as follows:

| Parser \ Mode | `wgs`     | `trans`   | `templ`   |
|---------------|-----------|-----------|-----------|
| `memory`      | Coverage  | Batch     | Batch     |
| `htslib`      | Coverage  | **ERROR** | **ERROR** |
| `stream`      | **ERROR** | Batch     | Batch     |

### Input Formats

Currently, we support input in FASTA and PBSim3 transcripts format.

**FOR FASTA FORMAT**: For read names, only characters before blank space are read.

A compatibility matrix is as follows:

| Parser \ Mode | `wgs`     | `trans`                     | `templ`                     |
|---------------|-----------|-----------------------------|-----------------------------|
| `memory`      | FASTA     | FASTA \| PBSim3 Transcripts | FASTA \| PBSim3 Transcripts |
| `htslib`      | FASTA     | **ERROR**                   | **ERROR**                   |
| `stream`      | **ERROR** | FASTA \| PBSim3 Transcripts | FASTA \| PBSim3 Transcripts |

### Library Construction Methods

### FASTA Parsers

## Changes Compared to Official ART Implementation

Changes on software function:

- [X] Supports 3 modes: `wgs`, `trans` and `templ`, similar to `pbsim3`.
- [X] Supports 3 FASTA parsers: `memory`, `htslib` and `stream`.
- [X] Supports 3 library construction methods: `se`, `pe` and `mp`.
- [X] Except FASTQ, support output in SAM and BAM format through HTSLib.
- [X] Support for masking detection was dropped.
- [X] Support for sequencers except Illumina dropped.
- [X] Support for the `aln` output format was dropped.
- [X] Built-in profiles are no longer supported. Users must specify the path to the existing profile they want to use.
- [ ] Parallelization using MPI and Boost ASIO.

Changes on software engineering stuff:

- Build systems changed to CMake.
- All C++ code was re-implemented in C++14 with radical removal of duplicated or unused code.
- Random generator was changed from GNU Science Library (GSL) to Boost or C++ standard library.
- Logging re-implemented using Boost.
- Multithreading support implemented using Boost.
- Largely eliminated POSIX-only routines by Boost.
- Argument parser implemented in Boost.

## Acknowledgements

This simulator is based on the works of [Weichun Huang](mailto:whduke@gmail.com) _et al._, under [GNU GPL v3](https://www.gnu.org/licenses/) license. The software is originally distributed [here](https://www.niehs.nih.gov/research/resources/software/biostatistics/art) with the following reference:

- W. Huang, L. Li, J. R. Myers, and G. T. Marth, _ART: a next-generation sequencing read simulator_, Bioinformatics (Oxford, England), vol. 28, no. 4, pp. 593–594, Feb. 2012, doi: [10.1093/bioinformatics/btr708](https://doi.org/10.1093/bioinformatics/btr708).

The bundled HTSLib library used MIT License with the following reference:

- J. K. Bonfield et al., _HTSlib: C library for reading/writing high-throughput sequencing data_, GigaScience, vol. 10, no. 2, p. giab007, Jan. 2021, doi: [10.1093/gigascience/giab007](https://doi.org/10.1093/gigascience/giab007).

## TODO

- Make it faster.
- Implement an ultrasonic sequence chopper and connect `trans` or `wgs` mode to it.
- Support MPI-based parallelization. Basic ideas:
  - For `htslib` parser, just divide sequencing depth.
  - For `memory` parser, skip records based on MPI rank.
  - For `stream` parser, skip records based on MPI rank.

- Support [Illumina Complete Long Read](https://www.illumina.com/products/by-brand/complete-long-reads-portfolio.html)?
- Support MAF output format?
- Working with >65535 CIGAR operations? See <https://github.com/lh3/minimap2?tab=readme-ov-file#working-with-65535-cigar-operations>

## FAQ

### Supported CPUs?

Although this application should theoretically support both endianness, only little endian is tested. That is, if you're working on an Intel or AMD CPU, this application should work fine.

### How to split produced pair-end/mate-pair sequencing results to 2 files?

This can be done through [`seqtk`](https://github.com/lh3/seqtk). For example, to split `tmp/test_small_pe/NC_001416.1.fq`:

```shell
# Read 1
seqtk seq tmp/test_small_pe/NC_001416.1.fq -1 > tmp/test_small_pe/NC_001416.1_1.fq
# Read 2
seqtk seq tmp/test_small_pe/NC_001416.1.fq -2 > tmp/test_small_pe/NC_001416.1_2.fq
```

### Is there an interface for Python, Java, and more?

We may develop a C interface in the future after the APIs and design of the core library are settled.

### How to add adaptors \& primers to the reads?

Currently, there's no support for such features in the simulator. However, you may manually chop your reference genome, add adapters to them, and use `templ` mode to introduce sequencing errors.

### I don't care about portability. How to make it wicked fast?

Easy. Set `USE_HTSLIB` to the latest HTSLib available on your system, `CMAKE_BUILD_TYPE` to `Release` or `RelWithDebInfo`, and `USE_RANDOM_GENERATOR` to `ONEMKL`. Please also make sure that your HTSLib had been linked with [libdeflate](https://github.com/ebiggers/libdeflate).
