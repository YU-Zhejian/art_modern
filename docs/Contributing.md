# Readme for Developers

## Motivation

ART is an excellent software for simulating reads from a reference genome. However, it comes with the following limitations:

- The implementation is not parallelized.
- The implementation may consume too much memory or fail on genomes that contain a limited number of chromosomes of enormous (larger than `signed int32`) sizes.
- The implementation may consume too much memory or fail on transcriptome or template collection that contains an enormous number of contigs (cDNAs or other types of template molecules).
- The implementation only supports unified coverage, which is not suitable for transcriptome simulation where each cDNA molecule has its own expression level.
- The implementation outputs alignments in SAM format, which is not space-efficient. We also spot some SAM records generated by `art_illumina` whose query length inferred from CIGAR strings differs from the actual query length.

So, we developed `art_modern` with the following ideas:

- Parallelization is implemented using another layer of abstraction, simulation job, which can be taken as a unit of work in one thread, etc.
- Writer for SAM output format was re-implemented using [HTSLib](https://www.htslib.org/), which allows supporting BAM and headless SAM/BAM output format with minimal modifications of code.
- Multiple FASTA parsers were added. For example, the `htslib` parser allows on-disk random access of enormous genomes without reading them into memory, while the `stream` parser allows streaming of FASTA files. All coordinates are now int64-based.
- The low-level I/O routines are made asynchronized to improve performance.
- Support other random number generators like Intel OneAPI Math Kernel Library (OneMKL).

## Common Development-Oriented Tasks

### Create Development Environment

Except [CMake](https://cmake.org) and other dependencies specified in [Install](Install.md), the development scripts also require other dependencies. Install [Conda](https://docs.conda.io/en/latest/) (Or [Mamba](https://mamba.readthedocs.io/en/latest/)/[MicroMamba](https://mamba.readthedocs.io/en/latest/micromamba.html)), and then execute:

```shell
conda env create -f art_modern.yml
```

### Testing

Some individual modules can be tested using CMake CTest system. Execute `ctest` in your building directory to test them.

Run `make testsmall` or `make testsmall-release` to run the integration tests using executables produced in `make build` and `make release`.

### Profiling

We have `./profile.sh ${PROFILER}` to perform profiling of the software with profiler `${PROFILER}`. Profilers may include:

- `intel-advisor` for Intel Advisor. Intel compilers with `-mtune=native` and `-O3` with `RelWithDebInfo` mode will be used.
- `intel-vtune` for Intel VTune Profiler. Intel compilers with `-mtune=native` and `-O3` with `RelWithDebInfo` mode will be used.
- `nsys` for NVIDIA Nsight Systems. Nvidia compiler with `-mtune=native` and `-O3` with `RelWithDebInfo` mode will be used.
- `valgrind` for Valgrind Callgrind. GCC with `Debug` mode will be used since optimization may produce instructions that are not supported by Valgrind.
- `amd-uprof` for AMD uProf. AMD compilers with `-mtune=native` and `-O3` with `RelWithDebInfo` mode will be used.

### Others

- Run `make fmt` to format the code using [`clang-format`](https://clang.llvm.org/docs/ClangFormat.html), [`sh`](https://github.com/mvdan/sh), [`cmake-format`](https://cmake-format.readthedocs.io/), and [`dos2unix`](https://www.freebsd.org/cgi/man.cgi?query=dos2unix&sektion=1).
- Run `make build` to build the executable using debug mode with default compiler found by CMake.
- Run `make release` to build the executable using release mode with default compiler found by CMake.
- Run `make scc` to count lines of code written. Note that this excludes third-party codes so should be preferred over pure `scc` in project root.
- Run `make touch` to touch all files in the repository. This **MAY** work when CMake does strange things like compiling the source files again and again.
- Run `make raw_data` to download essential test data useful to various integration tests, benchmarks, etc.

## Get Engaged

### Issues

You're welcome to submit issues on GitHub if you've encountered any problems while using this software. You're recommended to take advantage of the bug report templates, which will help us to understand your problem better. You may also submit issues if you're unclear about the docs or have some ideas improving the software itself.

### Pull Requests (PRs)

You're welcomed to send pull requests (PRs) to this project using the standard fork-and-pull-request workflow. However, please send an issue first to discuss the changes you're going to make (except spelling \& punctuation \& grammar issues), otherwise we may not be able to accept your PR.

Before you send a PR, please make sure that:

- `make testsmall` passes.
- You've run `make fmt` to format the code.
- You used Valgrind to check for memory leaks.
