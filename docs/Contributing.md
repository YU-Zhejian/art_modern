# Readme for Developers

## Motivation

ART is an excellent software for simulating reads from a reference genome. However, it comes with the following limitations:

- The implementation is not parallelized.
- The implementation may consume too much memory or fail on genomes that contain a limited number of chromosomes of enormous (larger than `signed int32`) sizes.
- The implementation may consume too much memory or fail on transcriptome or template collection that contains an enormous number of contigs (cDNAs or other types of template molecules).
- The implementation only supports unified coverage, which is not suitable for transcriptome simulation where each cDNA molecule has its own expression level.
- The implementation outputs alignments in SAM format, which is not space-efficient. We also spot some SAM records generated by `art_illumina` have CIGAR strings of inconsistent length.

So, we developed `art_modern` with the following ideas:

- Parallelization is implemented using another layer of abstraction, simulation job, which can be taken as a unit of work in one thread, etc.
- Writer for SAM output format was re-implemented using [HTSLib](https://www.htslib.org/), which allows supporting BAM and headless SAM/BAM output format with minimal modifications of code.
- Multiple FASTA parsers were added. For example, the `htslib` parser allows on-disk random access of enormous genomes without reading them into memory, while the `stream` parser allows streaming of FASTA files.
- The low-level I/O routines are made asyncronized to improve performance.
- Support other random number generators like Intel OneAPI Math Kernel Library (OneMKL).

## Common Development-Oriented Tasks

### Create Development Environment

Install [Conda](https://docs.conda.io/en/latest/) (Or [Mamba](https://mamba.readthedocs.io/en/latest/)/[MicroMamba](https://mamba.readthedocs.io/en/latest/micromamba.html)), and then execute:

```shell
conda env create -f art_modern.yml
```

Additional dependencies may include:

- [GNU Make](https://www.gnu.org/software/makel) is required to perform miscellaneous tasks, such as formatting the code, running test cases, performing profiling, etc.
- [Ninja](https://ninja-build.org) is used as the generator for the build system in the development environment.

### Testing

Some of the individual modules can be tested using CMake CTest system. Execute `ctest` in your building directory to test them.

Run `make testsmall` to run the integration tests using executables produced in `make build`.

### Profiling

Run `./profile.sh intel-advisor` to run the profiler using Intel Advisor. You have to have it installed to run this. You may also profile the software using `intel-vtune` (for Intyel VTune Profiler), `nsys` (For NVidia Nsight Systems), or `valgrind` (for Valgrind Callgrind) as the first parameter.

### Others

- Run `make fmt` to format the code.
- Run `make build` to build the executable using debug mode with default compiler found by CMake.
- Run `make scc` to count lines of code written.
- Run `make touch` to touch all files in the repository. This works when CMake does strange things like compiling the source files again and again.
- Run `make raw_data` to download essential test data useful to various integration tests, benchmarks, etc.

## Design Topics

### Parallelism

The parallelization strategy of different modes and input parsers are as follows:

| Parser \ Mode | `wgs`     | `trans`   | `templ`   |
|---------------|-----------|-----------|-----------|
| `memory`      | Coverage  | Batch     | Batch     |
| `htslib`      | Coverage  | **ERROR** | **ERROR** |
| `stream`      | **ERROR** | Batch     | Batch     |

A proposed MPI-based parallelization strategy is in [TODO.md](TODO.md).

## Get Engaged

### Issues

You're welcome to submit issues on GitHub if you've encountered any problems while using this software. Please make sure to include the following information:

- The version of your operating system and kernel, given by `uname -a`.
- Version information of the compiler, given by `gcc -v --verbose` or similiar.
- `art_modern --version` output.
- The CMake commandline you used to build the code.
- The CMake configuration log, if possible.
- The compilation log, if possible.
- The actual libraries linked to the executable. You may find that out using `ldd` or `readelf -d`.
- The git commit hash of the code you used.
- Attaching Valgrind memcheck output or profiler output is highly encouraged if possible.

You may also submit issues if you're unclear about the docs or have some ideas improving the software itself.

### Pull Requests (PRs)

You're welcomed to send pull requests (PRs) to this project using the standard fork-and-pull-request workflow. However, please send an issue first to discuss the changes you're going to make (except spelling \& punctuation \& grammar issues), otherwise we may not be able to accept your PR.

Before you send a PR, please make sure that:

- `make testsmall` passes.
- You've run `make fmt` to format the code.
- You used Valgrind to check for memory leaks.
